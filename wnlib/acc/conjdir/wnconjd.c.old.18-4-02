/********************************************************************

void wn_conj_direction_method(pcode,pval_min,vect,num_vars,pfunction,max_func_calls)

********************************************************************/
#include <stdio.h>
#include <math.h>

#include "wnlib.h"
#include "wnasrt.h"
#include "wnmem.h"
#include "wnabs.h"
#include "wnswap.h"
#include "wnrndd.h"

#include "wnvect.h"
#include "wnmat.h"

#include "wnconjd.h"
#include "wnconj.h"



#define MAX_EXPAND   (100.0)
#define MIN_CONTRACT (1.0/10.0)



int wn_conj_direction_debug = WN_CONJ_DIR_DBG_NONE;

local bool show_linesearch=FALSE;


local int num_vars;

local double **search_directions;
local int num_search_directions,max_num_search_directions;

local double *coord_x0s,*search_direction_x0s;
local double *coord_as,*search_direction_as;

local int num_func_calls;

local bool last_line_function_x_valid;
local double last_line_function_x,last_line_function_ret;



local double *buffer_vect,*save_vect,*save_direction;
local double (*save_pfunction)(double vect[]);


local bool force_optimize_stop_flag=FALSE;



void wn_force_conj_direction_stop(void)
{
  force_optimize_stop_flag = TRUE;
}


local double line_function(double x)
{
  double ret;

  if(last_line_function_x_valid)
  {
    if(x == last_line_function_x)
    {
      return(last_line_function_ret);
    }
  }

  wn_copy_vect(save_vect,buffer_vect,num_vars);
  wn_add_scaled_vect(save_vect,save_direction,x,num_vars);

  if(wn_conj_direction_debug >= WN_CONJ_DIR_DBG_ALL)
  {
    printf("function call %d at value\n",num_func_calls);
    wn_print_vect(save_vect,num_vars);
  }

  ++num_func_calls;

  ret = wn_clip_f((*save_pfunction)(save_vect));

  if(wn_conj_direction_debug >= WN_CONJ_DIR_DBG_ALL)
  {
    printf("function value is %lg\n",ret);
    fflush(stdout);
  }

  last_line_function_x_valid = TRUE;
  last_line_function_x = x;
  last_line_function_ret = ret;

  return(ret);
}


local void fit_parabola_2pa(int *pcode,double *px0,double *pb,
			    double a,
			    double x1,double y1,
			    double x2,double y2)
{
  double b,c;

  if(a <= 0.0)
  {
    *pcode = WN_SINGULAR;
    return;
  }

  wn_fit_traditional_parabola_2pa(pcode,&b,&c,a,x1,y1,x2,y2);

  if(*pcode != WN_SUCCESS)
  {
    return;
  }

  wn_convert_parabola_traditional_to_centered(pcode,px0,pb,a,b,c);
}


local void line_minimize
(
  double vect[],
  double direction[],
  double *pval_min,
  double *psave_x0,
  double *psave_a,
  double (*pfunction)(double vect[])
)
{
  double ax,bx,cx,x0,fa,fb,fc,fx0;
  double a,b;
  double old_x0,old_a;
  bool code;

  if(wn_conj_direction_debug >= WN_CONJ_DIR_DBG_LINESEARCH)
  {
    printf("start line minimize.\n");
  }

  last_line_function_x_valid = FALSE;

  wn_copy_vect(buffer_vect,vect,num_vars);
  save_vect = vect;
  save_direction = direction;
  save_pfunction = pfunction;

  old_x0 = *psave_x0;
  old_a = *psave_a;

  bx = 0.0;
  fb = *pval_min;

  if(old_x0 == 0.0)
  {
    old_x0 = 1.0;
  }

  ax = old_x0*wn_random_double_between(0.9,1.1);
  fa = line_function(ax);

  if(!(old_a > 0.0))
  {
    goto simple_parabola_fit;
  }

  /* the curvature along a search direction is constant for a 
     quadratic function, therefore, try to use the curvature
     from the last search */
  fit_parabola_2pa(&code,&x0,&b,old_a,ax,fa,bx,fb);
  if((code != WN_SUCCESS)||
     (!(wn_abs(x0)<MAX_EXPAND*wn_abs(old_x0))&&(*psave_x0 != 0.0)))
  {
    goto simple_parabola_fit;
  }   

  cx = x0;
  fc = line_function(cx);

  wn_fit_parabola_3p(&code,&a,&x0,&b,ax,fa,bx,fb,cx,fc);

  if((code != WN_SUCCESS)||(!(a > 0.0))||
     (!(wn_abs(x0)<MAX_EXPAND*wn_abs(old_x0))&&(*psave_x0 != 0.0)))
  {
    goto full_linesearch;
  }   

  if(!(b < fb))
  {
    goto full_linesearch;
  }
  if((!(fc < fb))||(!(fc < fa)))
  {
    /* evaluate one more point */
    goto evaluate_x0;
  }

  /* is it economical to evaluate one more point? */
  if((fb-b) <= 1.5*(fb-fc))
  { 
    /* do not evaluate one more point */
    wn_swap(fb,fc,double);
    wn_swap(bx,cx,double);
    goto finish;
  }
  else
  {
    /* evaluate one more point */
    goto evaluate_x0;
  }

simple_parabola_fit:
  if(fa < fb)
  {
    cx = 2.0*ax*wn_random_double_between(0.8,1.2);
  }
  else
  {
    cx = -1.0*ax*wn_random_double_between(0.8,1.2);
  }

  fc = line_function(cx);

  wn_fit_parabola_3p(&code,&a,&x0,&b,ax,fa,bx,fb,cx,fc);

  if((code != WN_SUCCESS)||(!(a > 0.0))||
     (!(wn_abs(x0)<MAX_EXPAND*wn_abs(old_x0))&&(*psave_x0 != 0.0)))
  {
    goto full_linesearch;
  }   

evaluate_x0:
  fx0 = line_function(x0);

  if(!(fx0 <= fb))
  {
    goto full_linesearch;
  }

  fb = fx0;
  bx = x0;

  if(!(fa <= fc))
  {
    wn_swap(fa,fc,double);
    wn_swap(ax,cx,double);
  }
  if(!(fb <= fa))
  {
    wn_swap(fb,fa,double);
    wn_swap(bx,ax,double);
  }

  goto finish;

full_linesearch: ;

  /*
  printf("now.\n");
  */
  do
  {
    if(ax == bx)
    {
      if(wn_random_bit())
      {
        ax += wn_random_double_between(-1.0,1.0);
        fa = line_function(ax);
      }
      else
      {
        bx += wn_random_double_between(-1.0,1.0);
        fb = line_function(bx);
      }
    }
    if(ax == cx)
    {
      if(wn_random_bit())
      {
        ax += wn_random_double_between(-1.0,1.0);
        fa = line_function(ax);
      }
      else
      {
        cx += wn_random_double_between(-1.0,1.0);
        fc = line_function(cx);
      }
    }
    if(bx == cx)
    {
      if(wn_random_bit())
      {
        bx += wn_random_double_between(-1.0,1.0);
        fb = line_function(bx);
      }
      else
      {
        cx += wn_random_double_between(-1.0,1.0);
        fc = line_function(cx);
      }
    }
  } while((ax == bx)||(ax == cx)||(bx == cx));
  wn_minimize_1d_raw(&code,&fa,&fb,&fc,&ax,&bx,&cx,fb,&line_function,1,20);
  /*
  printf("l = %lf\n",bx);
  */

finish: ;

  /*
  if(show_linesearch)
  {
    printf("ax=%lg,bx=%lg,cx=%lg,old_x0=%lg\n",ax,bx,cx,old_x0);
  }
  */

  wn_copy_vect(vect,buffer_vect,num_vars);

  /* compute *psave_x0 */
  if(wn_abs(bx) < MIN_CONTRACT*wn_abs(old_x0))
  {
    if(bx < 0.0)
    {
      *psave_x0 = -MIN_CONTRACT*wn_abs(old_x0);
    }
    else
    {
      *psave_x0 = MIN_CONTRACT*wn_abs(old_x0);
    }
  }
  else
  {
    *psave_x0 = bx;
  }

  /* compute *psave_a */
  wn_fit_parabola_3p(&code,&a,&x0,&b,ax,fa,bx,fb,cx,fc);

  if((code != WN_SUCCESS)||(!(a > 0.0)))
  {
    *psave_a = 0.0;
  }   
  else
  {
    *psave_a = a;
  }

  if(*pval_min == fb)
  {
    if(wn_conj_direction_debug >= WN_CONJ_DIR_DBG_LINESEARCH)
    {
      printf("finish line minimize.\n");
      fflush(stdout);
    }
    return;  /* do not move if no improvement */
  }

  wn_add_scaled_vect(vect,direction,bx,num_vars);

  *pval_min = fb;

  if(wn_conj_direction_debug >= WN_CONJ_DIR_DBG_LINESEARCH)
  {
    printf("finish line minimize.\n");
    fflush(stdout);
  }
}


void wn_conj_direction_method
(
  int *pcode,
  double *pval_min,
  double vect[],
  double initial_coord_x0s[],
  int passed_num_vars,
  double (*pfunction)(double vect[]),
  int max_func_calls
)
{
  int i,j,iteration;
  double *old_vect,*coord_direction;
  double *new_search_direction;
  double old_val_min;

  wn_gpmake("no_free");

  force_optimize_stop_flag = FALSE;

  num_vars = passed_num_vars;
  max_num_search_directions = num_vars;

  wn_make_vect(&buffer_vect,num_vars);
  search_directions = (double **)wn_zalloc(
		  max_num_search_directions*sizeof(double *));
  wn_make_vect(&old_vect,num_vars);
  wn_make_vect(&coord_direction,num_vars);
  wn_make_vect(&coord_x0s,num_vars);
  wn_make_vect(&search_direction_x0s,max_num_search_directions);
  wn_make_vect(&coord_as,num_vars);
  wn_make_vect(&search_direction_as,max_num_search_directions);
  if(initial_coord_x0s == NULL)
  {
    wn_zero_vect(coord_x0s,num_vars);
  }
  else
  {
    wn_copy_vect(coord_x0s,initial_coord_x0s,num_vars);
  }
  wn_zero_vect(search_direction_x0s,max_num_search_directions);
  wn_zero_vect(coord_as,num_vars);
  wn_zero_vect(search_direction_as,max_num_search_directions);

  num_search_directions = 0;

  num_func_calls = 0;

  last_line_function_x_valid = FALSE;
  *pval_min = wn_clip_f((*pfunction)(vect));
  ++num_func_calls;

  for(iteration=0;;++iteration)
  {
    if(wn_conj_direction_debug >= WN_CONJ_DIR_DBG_PASSES)
    {
      printf("iteration = %d ********************************\n",iteration);
      printf("ob = %lg\n",*pval_min);
      fflush(stdout);
    }
    /*
    (void)getchar();
    */

    old_val_min = *pval_min;
    wn_copy_vect(old_vect,vect,num_vars);

    /* minimize along acceleration search directions */
    if(wn_conj_direction_debug >= WN_CONJ_DIR_DBG_LINESEARCH)
    {
      printf("start acceleration line minimizations ------------------\n");
    }
    for(i=0;i<num_search_directions;++i)
    {
      if(wn_conj_direction_debug >= WN_CONJ_DIR_DBG_LINESEARCH)
      {
        printf("acceleration line search %d\n",i);
      }

      line_minimize(vect,search_directions[i],pval_min,
		    &(search_direction_x0s[i]),&(search_direction_as[i]),
		    pfunction);

      if(
	  ((max_func_calls < WN_IHUGE)&&(num_func_calls > max_func_calls))
	    ||
          force_optimize_stop_flag
	)
      {
        *pcode = WN_SUBOPTIMAL;
	goto finish;
      }
    }

    /* minimize along coordinate directions */
    if(wn_conj_direction_debug >= WN_CONJ_DIR_DBG_LINESEARCH) 
    {
      printf("start coordinate line minimizations ------------------\n");
    }
    for(i=0;i<num_vars;++i)
    {
      if(wn_conj_direction_debug >= WN_CONJ_DIR_DBG_LINESEARCH)
      {
        printf("coord line search %d\n",i);
      }

      coord_direction[i] = 1.0;

      line_minimize(vect,coord_direction,pval_min,
		    &(coord_x0s[i]),&(coord_as[i]),
		    pfunction);

      coord_direction[i] = 0.0;

      if(
	  ((max_func_calls < WN_IHUGE)&&(num_func_calls > max_func_calls))
	    ||
          force_optimize_stop_flag
	)
      {
        *pcode = WN_SUBOPTIMAL;
	goto finish;
      }
    }

    if(*pval_min >= old_val_min)
    {
      wn_assert(*pval_min == old_val_min);

      *pcode = WN_SUCCESS;
      break;
    }

    /* compute new acceleration search direction */
    if(num_search_directions < max_num_search_directions)
    {
      wn_make_vect(&new_search_direction,num_vars);
      for(i=num_search_directions;i>0;--i)
      {
        search_directions[i] = search_directions[i-1];
	search_direction_x0s[i] = search_direction_x0s[i-1];
	search_direction_as[i] = search_direction_as[i-1];
      }
      search_directions[0] = new_search_direction;
      search_direction_x0s[0] = 1.0;
      search_direction_as[0] = 0.0;

      ++num_search_directions;
    }
    else
    {
      new_search_direction = search_directions[max_num_search_directions-1];
      for(i=max_num_search_directions-1;i>0;--i)
      {
        search_directions[i] = search_directions[i-1];
	search_direction_x0s[i] = search_direction_x0s[i-1];
	search_direction_as[i] = search_direction_as[i-1];
      }
      search_directions[0] = new_search_direction;
      search_direction_x0s[0] = 1.0;
      search_direction_as[0] = 0.0;
    }

    for(j=0;j<num_vars;++j)
    {
      new_search_direction[j] = vect[j] - old_vect[j];
    }
  }

finish: ;

  force_optimize_stop_flag = FALSE;
  last_line_function_x_valid = FALSE;

  wn_gpfree();
}



